package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"
	"log/slog"
	"regexp"
	"strings"
	"time"

	ethCommon "github.com/ethereum/go-ethereum/common"
	"github.com/fluidity-money/long.so/lib/features"
)

// reWallet to use to validate the wallet address before continuing with verification.
var reWallet = regexp.MustCompile("(0x)?[A-Z0-9a-z]{0,40}")

// TimeToLive on the request before sending a customised failure.
const TimeToLive = 10 * time.Second

// RequestTokens is the resolver for the requestTokens field.
func (r *mutationResolver) RequestTokens(ctx context.Context, wallet string) (string, error) {
	// Get the user's IP address to prevent them from spamming this
	// incase our rate limiting is skipped somehow (it's good to be cautious.)
	ipAddr := ctx.Value("X-Forwarded-For")
	if enabled := r.F.Is(features.FeatureFaucetEnabled); !enabled {
		slog.Error("faucet is currently disabled",
			"ip addr", ipAddr,
			"submitted query", wallet,
		)
		return "", fmt.Errorf("faucet disabled")
	}
	slog.Debug("handled request to send some tokens",
		"ip addr", ipAddr,
		"wallet", wallet,
	)
	// Make sure the wallet they've given is actually valid.
	if !reWallet.MatchString(wallet) {
		slog.Error("bad wallet request",
			"ip addr", ipAddr,
			"submitted query", wallet,
		)
		return "", fmt.Errorf("bad wallet")
	}
	if r.F.Is(features.FeatureFaucetStakersOnly) {
		if ok := r.Stakers[strings.ToLower(wallet)]; !ok {
			slog.Error("user who is not a staker requested tokens",
				"ip addr", ipAddr,
				"submitted wallet", wallet,
			)
			return "", fmt.Errorf("not staker")
		}
	}
	// As a precaution, now we can check using the go-ethereum codebase for this.
	if isEthAddr := ethCommon.IsHexAddress(wallet); !isEthAddr {
		return "", fmt.Errorf("bad wallet")
	}
	// Get the local queue, assuming the concurrency on this Lambda(?) is limited.
	resp := make(chan error)
	r.Queue <- FaucetReq{
		Addr: ethCommon.HexToAddress(wallet),
		Resp: resp,
	}
	// Send back to the user the status on this once we're done.
	// Assuming the throughput on the chain is good enough. Have a
	// time to live of 15 seconds or so.
	t := time.NewTimer(TimeToLive)
	select {
	case <-t.C:
		slog.Error("error sending amounts.",
			"ip addr", ipAddr,
			"time to live", TimeToLive,
		)
		return "", fmt.Errorf("timed out")
	case err := <-resp:
		t.Stop() // Cancel the timer so it doesn't fire needlessly.
		if err != nil {
			slog.Error("error sending amounts.",
				"ip addr", ipAddr,
				"err", err,
			)
			return "", fmt.Errorf("error sending")
		}
	}
	// Mark that we had success in the database. If worst case
	// scenario, and somewhere in this process we fail, the user will
	// get more if they request again. This is not the end of the
	// world for us.
	//TODO
	return "", nil
}

// Healthcheck is the resolver for the healthcheck field.
func (r *queryResolver) Healthcheck(ctx context.Context) (int, error) {
	return 0, nil // TODO
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
