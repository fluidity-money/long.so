package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"
	"log/slog"
	"time"
	"strings"

	"github.com/fluidity-money/long.so/lib/features"

	"github.com/fluidity-money/long.so/cmd/faucet.superposition/lib/faucet"
)

// TimeToLive on the request before sending a customised failure.
const TimeToLive = 10 * time.Second

// RequestTokens is the resolver for the requestTokens field.
func (r *mutationResolver) RequestTokens(ctx context.Context, wallet_ string) (string, error) {
	wallet := strings.ToLower(wallet_)
	// Get the user's IP address to prevent them from spamming this
	// incase our rate limiting is skipped somehow (it's good to be cautious.)
	ipAddr, _ := ctx.Value("X-Forwarded-For").(string)
	if enabled := r.F.Is(features.FeatureFaucetEnabled); !enabled {
		slog.Error("faucet is currently disabled",
			"ip addr", ipAddr,
			"submitted query", wallet,
		)
		return "", fmt.Errorf("faucet disabled")
	}
	slog.Debug("handled request to send some tokens",
		"ip addr", ipAddr,
		"wallet", wallet,
	)
	// Make sure the wallet they've given is actually valid.
	if validWallet := IsValidWallet(wallet); !validWallet {
		slog.Error("bad wallet request",
			"ip addr", ipAddr,
			"submitted query", wallet,
		)
		return "", fmt.Errorf("bad wallet")
	}
	// Check if they're a staker for their bonus.
	isFlyStaker, err := IsUserStaker(wallet)
	if err != nil {
		slog.Error("error requesting whether the user is a staker",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
		)
		return "", fmt.Errorf("error requesting: %v", err)
	}
	// If the user is not a fly staker, kick them out if this feature is enabled.
	if r.F.Is(features.FeatureFaucetStakersOnly) && !isFlyStaker {
		slog.Error("non staker requested spn airdrop",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
		)
		return "", fmt.Errorf("not staker")
	}
	// Check if the user is within the window to make requests.
	// Checks if there are any rows that exceed a 5 hour addition to
	// the updated time to see if they're within that window.
	attempts, err := r.DB.
		Raw("SELECT 1 FROM faucet_requests WHERE (addr = ? OR ip_addr = ?) AND updated_by + INTERVAL '5 hours' > CURRENT_TIMESTAMP", wallet, ipAddr).
		Rows()
	if err != nil {
		slog.Error("failure to get attempts",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
			"err", err,
		)
		return "", fmt.Errorf("internal error")
	}
	defer attempts.Close()
	if attempts.Next() { // If this happens, then we got a row that's bad.
		slog.Error("too many requests made",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
			"err", err,
		)
		return "", fmt.Errorf("too many requests")
	}
	// Mark that the request was serviced so we don't double up.
	err = r.DB.
		Table("faucet_requests").
		Create(faucet.FaucetRequest{
			Addr:      wallet,
			IpAddr:    ipAddr,
			CreatedBy: time.Now(),
			UpdatedBy: time.Now(),
			WasSent:   false,
			IsFlyStaker:  isFlyStaker,
		}).
		Error
	if err != nil {
		slog.Error("failed to upsert a faucet request",
			"ip addr", ipAddr,
			"submitted wallet", wallet,
			"err", err,
		)
		return "", fmt.Errorf("internal error")
	}
	return "", nil
}

// Healthcheck is the resolver for the healthcheck field.
func (r *queryResolver) Healthcheck(ctx context.Context) (int, error) {
	return 0, nil // TODO
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
