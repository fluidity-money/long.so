package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"errors"
	"fmt"
	"math/big"
	"strconv"
	"time"

	"github.com/fluidity-money/long.so/cmd/graphql.ethereum/graph/model"
	"github.com/fluidity-money/long.so/cmd/graphql.ethereum/lib/erc20"
	"github.com/fluidity-money/long.so/lib/features"
	"github.com/fluidity-money/long.so/lib/math"
	"github.com/fluidity-money/long.so/lib/types"
	"github.com/fluidity-money/long.so/lib/types/seawater"
	"gorm.io/gorm"
)

// Token is the resolver for the token field.
func (r *amountResolver) Token(ctx context.Context, obj *model.Amount) (model.Token, error) {
	if obj == nil {
		return model.Token{}, fmt.Errorf("empty amount")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		return MockToken(obj.Token.String())
	}
	name, symbol, totalSupply, err := erc20.GetErc20Details(
		ctx,
		r.Geth,
		obj.Token,
	)
	if err != nil {
		return model.Token{}, fmt.Errorf("erc20 token %#v: %v", obj.Token, err)
	}
	return model.Token{
		Address:     obj.Token.String(),
		Name:        name,
		Symbol:      symbol,
		TotalSupply: totalSupply.String(),
		Decimals:    obj.Decimals,
	}, nil
}

// ValueUnscaled is the resolver for the valueUnscaled field.
func (r *amountResolver) ValueUnscaled(ctx context.Context, obj *model.Amount) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("amount empty")
	}
	return obj.ValueUnscaled.String(), nil
}

// ValueScaled is the resolver for the valueScaled field.
func (r *amountResolver) ValueScaled(ctx context.Context, obj *model.Amount) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty amount")
	}
	amt := obj.ValueUnscaled
	return amt.ScaleStr(obj.Decimals), nil
}

// ValueUsd is the resolver for the valueUsd field.
func (r *amountResolver) ValueUsd(ctx context.Context, obj *model.Amount) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty amount")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		// If we're mocking the graph, then we take the uncaled
		// amount, and we simply divide it by 1e6, then we divide
		// it by 0.04 unless the token is fUSDC.
		value := obj.ValueUnscaled
		dividedAmt := value.Scale(obj.Decimals) //value / (10 ** decimals)
		switch obj.Token {
		case r.C.FusdcAddr:
			// 4 decimals
			return fmt.Sprintf("%0.8f", dividedAmt), nil
		default:
			//value / (10 ** decimals) * 0.04
			x := new(big.Float).Set(dividedAmt)
			x.Quo(dividedAmt, new(big.Float).SetFloat64(0.04))
			return fmt.Sprintf("%0.8f", x), nil
		}
	}
	if obj.ValueUnscaled.Cmp(types.EmptyUnscaledNumber().Int) == 0 {
		return "0", nil
	}
	// If the pool is the fUSDC address, then we can just skip the
	// lookup here and report $1 (assuming we maintain the peg.)
	if obj.Token == r.C.FusdcAddr {
		return obj.ValueUnscaled.ScaleStr(5), nil
	}
	// Use the final tick function to get the row.
	var finalTick struct {
		FinalTick types.Number
	}
	err := r.DB.Table("seawater_final_ticks_1").
		Select("final_tick").
		Where("pool = ?", obj.Token).
		First(&finalTick).
		Error
	if err != nil {
		return "", err
	}
	sqrtPrice := math.GetSqrtRatioAtTick(finalTick.FinalTick.Big())
	price := math.GetPriceAtSqrtRatio(sqrtPrice)

	// amount * price / (10 ^ fusdcDecimals)
	d := new(big.Int).SetInt64(10)
	d.Exp(d, new(big.Int).SetInt64(int64(r.C.FusdcDecimals)), nil)
	valueScaled := obj.ValueUnscaled.Quo(obj.ValueUnscaled.Int, d)
	value := new(big.Rat).SetInt(valueScaled)
	price.Mul(price, value)

	return price.FloatString(5), nil
}

// Fusdc is the resolver for the fusdc field.
func (r *queryResolver) Fusdc(ctx context.Context) (t model.Token, err error) {
	name, symbol, totalSupply, err := erc20.GetErc20Details(
		ctx,
		r.Geth,
		r.C.FusdcAddr,
	)
	if err != nil {
		return t, fmt.Errorf("erc20 at %#v: %v", r.C.FusdcAddr, err)
	}
	return model.Token{
		Address:     r.C.FusdcAddr.String(),
		Name:        name,
		Symbol:      symbol,
		TotalSupply: totalSupply.String(),
		Decimals:    r.C.FusdcDecimals,
	}, nil
}

// Pools is the resolver for the pools field.
func (r *queryResolver) Pools(ctx context.Context) (pools []seawater.Pool, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		pools = MockSeawaterPools()
		return
	}
	err = r.DB.Table("events_seawater_newpool").Scan(&pools).Error
	return pools, err
}

// GetPool is the resolver for the getPool field.
func (r *queryResolver) GetPool(ctx context.Context, token string) (pool *seawater.Pool, err error) {
	tokenAddress := types.AddressFromString(token)
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		pool = MockGetPool(tokenAddress.String())
		return
	}
	err = r.DB.Table("events_seawater_newpool").
		Where("token = ?", tokenAddress).
		Scan(&pool).
		Error
	return
}

// GetPoolPositions is the resolver for the getPoolPositions field.
func (r *queryResolver) GetPoolPositions(ctx context.Context, pool string, first *int, after *int) (positions model.SeawaterPositions, err error) {
	p := types.AddressFromString(pool)
	// If the user didn't set pagination, or they exceeded the restriction on the limit.
	if first == nil || *first > PoolPositionsPageSize {
		fst := PoolPositionsPageSize
		first = &fst
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = MockGetPoolPositions(p)
		return
	}
	stmt := r.DB.Table("seawater_active_positions_1").
		Where("pool = ?", p).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("pos_id > ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	// If we actually got return data here, we want to set it so we
	// can start to paginate.
	var to int
	if l := len(pos); l > 0 {
		to = int(pos[l-1].CreatedBy.Unix())
	}
	positions = model.SeawaterPositions{
		From:      *first,
		To:        to,
		Pool:      &p,
		Positions: pos,
	}
	return
}

// GetPosition is the resolver for the getPosition field.
func (r *queryResolver) GetPosition(ctx context.Context, id int) (position *seawater.Position, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		position = MockGetPosition(id)
		return
	}
	err = r.DB.Table("seawater_positions_1").
		Where("pos_id = ?", id).
		Scan(&position).
		Error
	return
}

// GetPositions is the resolver for the getPositions field.
func (r *queryResolver) GetPositions(ctx context.Context, wallet string, first *int, after *int) (positions model.SeawaterPositions, err error) {
	w := types.AddressFromString(wallet)
	// If the user didn't set the limit, or they requested too much.
	if first == nil || *first > PoolPositionsPageSize {
		fst := PoolPositionsPageSize
		first = &fst
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = MockGetPoolPositions("0x65dfe41220c438bf069bbce9eb66b087fe65db36")
		return
	}
	stmt := r.DB.Table("seawater_active_positions_1").
		Where("owner = ?", w).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("pos_id < ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	positions = model.SeawaterPositions{
		From:      pos[0].Id,
		To:        pos[len(pos)-1].Id,
		Wallet:    &w,
		Positions: pos,
	}
	return
}

// GetWallet is the resolver for the getWallet field.
func (r *queryResolver) GetWallet(ctx context.Context, address string) (wallet *model.Wallet, err error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		return &model.Wallet{Address: types.AddressFromString(address)}, nil
	}
	wallet = &model.Wallet{
		Address: types.AddressFromString(address),
	}
	return
}

// GetSwaps is the resolver for the getSwaps field.
func (r *queryResolver) GetSwaps(ctx context.Context, pool string, first *int, after *int) (swaps model.GetSwaps, err error) {
	poolAddress := types.AddressFromString(pool)
	// If there was no first supplied, or they went past the limit on pages.
	if first == nil || *first > SwapPositionsPageSize {
		fst := SwapPositionsPageSize
		first = &fst
	}
	if after == nil {
		aft := 0
		after = &aft
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		d := MockSwaps(r.C.FusdcAddr, 150, "0x65dfe41220c438bf069bbce9eb66b087fe65db36")
		return model.GetSwaps{d}, nil
	}
	var d []model.SeawaterSwap
	// DB.RAW doesn't support chaining
	err = r.DB.Raw(
		"SELECT * FROM seawater_swaps_1(?, ?) WHERE (token_in = ? OR token_out = ?) AND timestamp > ? ORDER BY timestamp DESC LIMIT ?",
		r.C.FusdcAddr,
		r.C.FusdcDecimals,
		poolAddress,
		poolAddress,
		*after,
		*first,
	).
		Scan(&d).
		Error
	if err != nil {
		return
	}
	// If we actually got return data here, we want to set it so we
	// can start to paginate.
	var to int
	if l := len(d); l > 0 {
		to = d[l-1].Timestamp
	}
	swaps.Data = model.SeawaterSwaps{
		From:  *first,
		To:    to,
		Pool:  &poolAddress,
		Swaps: d,
	}
	return
}

// GetSwapsForUser is the resolver for the getSwapsForUser field.
func (r *queryResolver) GetSwapsForUser(ctx context.Context, wallet string, first *int, after *int) (swaps model.GetSwapsForUser, err error) {
	walletAddress := types.AddressFromString(wallet)
	// If the user requested too large a limit, or they didn't supply anything.
	if first == nil || *first > PoolPositionsPageSize {
		fst := PoolPositionsPageSize
		first = &fst
	}
	if after == nil {
		aft := 0
		after = &aft
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		d := MockSwaps(r.C.FusdcAddr, 150, walletAddress)
		return model.GetSwapsForUser{d}, nil
	}
	var d []model.SeawaterSwap
	// DB.RAW doesn't support chaining
	err = r.DB.Raw(
		"SELECT * FROM seawater_swaps_1(?, ?) WHERE sender = ? AND id > ? ORDER BY timestamp DESC LIMIT ?",
		r.C.FusdcAddr,
		r.C.FusdcDecimals,
		walletAddress,
		*after,
		*first,
	).
		Scan(&d).
		Error
	if err != nil {
		return
	}
	// If we actually got return data here, we want to set it so we
	// can start to paginate.
	var to int
	if l := len(d); l > 0 {
		to = d[l-1].Timestamp
	}
	swaps.Data = model.SeawaterSwaps{
		From:   *first,
		To:     to,
		Wallet: &walletAddress,
		Swaps:  d,
	}
	return
}

// TickLower is the resolver for the tickLower field.
func (r *seawaterLiquidityResolver) TickLower(ctx context.Context, obj *model.SeawaterLiquidity) (tick int, err error) {
	if obj == nil {
		return 0, fmt.Errorf("no pool obj")
	}
	tick, err = strconv.Atoi(obj.TickLower)
	return
}

// TickUpper is the resolver for the tickUpper field.
func (r *seawaterLiquidityResolver) TickUpper(ctx context.Context, obj *model.SeawaterLiquidity) (tick int, err error) {
	if obj == nil {
		return 0, fmt.Errorf("no pool obj")
	}
	tick, err = strconv.Atoi(obj.TickUpper)
	return
}

// ID is the resolver for the id field.
func (r *seawaterPoolResolver) ID(ctx context.Context, obj *seawater.Pool) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty pool")
	}
	return obj.Token.String(), nil
}

// Address is the resolver for the address field.
func (r *seawaterPoolResolver) Address(ctx context.Context, obj *seawater.Pool) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("no pool obj")
	}
	return obj.Token.String(), nil
}

// TickSpacing is the resolver for the tickSpacing field.
func (r *seawaterPoolResolver) TickSpacing(ctx context.Context, obj *seawater.Pool) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("no pool obj")
	}
	return strconv.Itoa(int(obj.TickSpacing)), nil
}

// Token is the resolver for the token field.
func (r *seawaterPoolResolver) Token(ctx context.Context, obj *seawater.Pool) (t model.Token, err error) {
	if obj == nil {
		return t, fmt.Errorf("no pool obj")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		return MockToken(obj.Token.String())
	}
	name, symbol, totalSupply, err := erc20.GetErc20Details(
		ctx,
		r.Geth,
		obj.Token,
	)
	if err != nil {
		return t, fmt.Errorf("erc20 at %#v: %v", obj.Token, err)
	}
	return model.Token{
		Address:     obj.Token.String(),
		Name:        name,
		Symbol:      symbol,
		TotalSupply: totalSupply.String(),
		Decimals:    int(obj.Decimals),
	}, nil
}

// Price is the resolver for the price field.
func (r *seawaterPoolResolver) Price(ctx context.Context, obj *seawater.Pool) (string, error) {
	// Get the last price item for the pool given.
	if obj == nil {
		return "", fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockPriceOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return "", err
		}
		return daily[0], nil
	}
	var result model.PriceResult
	err := r.DB.Table("seawater_final_ticks_1").
		Where("pool = ?", obj.Token).
		First(&result).
		Error
	switch err {
	case gorm.ErrRecordNotFound:
		return "0", nil
	case nil:
		return result.Price(r.C.FusdcDecimals, int(obj.Decimals)), nil
	default:
		return "", err
	}
}

// PriceOverTime is the resolver for the priceOverTime field.
func (r *seawaterPoolResolver) PriceOverTime(ctx context.Context, obj *seawater.Pool) (price model.PriceOverTime, err error) {
	const (
		maxDays   = 31
		maxMonths = 12
	)
	if obj == nil {
		return price, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockPriceOverTime(maxDays, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return price, err
		}
		monthly, _, _, err := MockPriceOverTime(maxMonths, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return price, err
		}
		return model.PriceOverTime{daily, monthly}, nil
	}
	var daily, monthly []model.PriceResult
	err = r.DB.Table("seawater_final_ticks_daily_1").
		Where("pool = ?", obj.Token).
		Limit(maxDays).
		Scan(&daily).
		Error
	if err != nil {
		return
	}
	err = r.DB.Table("seawater_final_ticks_monthly_1").Where("pool = ?", obj.Token).Limit(maxMonths).Scan(&monthly).Error
	if err != nil {
		return
	}
	for _, d := range daily {
		price.Daily = append(price.Daily, d.Price(r.C.FusdcDecimals, int(obj.Decimals)))
	}
	for _, m := range monthly {
		price.Monthly = append(price.Monthly, m.Price(r.C.FusdcDecimals, int(obj.Decimals)))
	}
	return price, nil
}

// VolumeOverTime is the resolver for the volumeOverTime field.
func (r *seawaterPoolResolver) VolumeOverTime(ctx context.Context, obj *seawater.Pool) (vol model.VolumeOverTime, err error) {
	const (
		maxDays   = 31
		maxMonths = 12
	)
	if obj == nil {
		return vol, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return vol, err
		}
		monthly, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return vol, err
		}
		return model.VolumeOverTime{daily, monthly}, nil
	}
	var dailyResults, monthlyResults []struct {
		Token1Token    types.Address
		Token1Decimals int
		Timestamp      int
		// DailyTimestamp or MonthlyTimestamp
		IntervalTimestamp   time.Time
		FusdcValueUnscaled  types.UnscaledNumber
		Token1ValueUnscaled types.UnscaledNumber
	}
	err = r.DB.Table("seawater_pool_swap_volume_daily_1").
		Where("token1_token = ?", obj.Token).
		Limit(maxDays).Scan(&dailyResults).
		Error
	if err != nil {
		return
	}
	err = r.DB.Table("seawater_pool_swap_volume_monthly_1").
		Where("token1_token = ?", obj.Token).Limit(maxMonths).
		Scan(&monthlyResults).
		Error
	if err != nil {
		return
	}
	for _, d := range dailyResults {
		vol.Daily = append(vol.Daily, model.PairAmount{
			Timestamp: d.Timestamp,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     int(d.IntervalTimestamp.Unix()),
				ValueUnscaled: d.FusdcValueUnscaled,
			},
			Token1: model.Amount{
				Token:         d.Token1Token,
				Decimals:      d.Token1Decimals,
				Timestamp:     int(d.IntervalTimestamp.Unix()),
				ValueUnscaled: d.Token1ValueUnscaled,
			},
		})
	}
	for _, m := range monthlyResults {
		vol.Monthly = append(vol.Monthly, model.PairAmount{
			Timestamp: m.Timestamp,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     int(m.IntervalTimestamp.Unix()),
				ValueUnscaled: m.FusdcValueUnscaled,
			},
			Token1: model.Amount{
				Token:         m.Token1Token,
				Decimals:      m.Token1Decimals,
				Timestamp:     int(m.IntervalTimestamp.Unix()),
				ValueUnscaled: m.Token1ValueUnscaled,
			},
		})
	}
	return vol, nil
}

// LiquidityOverTime is the resolver for the liquidityOverTime field.
func (r *seawaterPoolResolver) LiquidityOverTime(ctx context.Context, obj *seawater.Pool) (liq model.LiquidityOverTime, err error) {
	if obj == nil {
		return liq, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return liq, err
		}
		monthly, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return liq, err
		}
		return model.LiquidityOverTime{daily, monthly}, nil
	}
	return liq, nil // TODO
}

// TvlOverTime is the resolver for the tvlOverTime field.
func (r *seawaterPoolResolver) TvlOverTime(ctx context.Context, obj *seawater.Pool) (tvl model.TvlOverTime, err error) {
	if obj == nil {
		return tvl, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		daily, _, _, err := MockPriceOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return tvl, err
		}
		monthly, _, _, err := MockPriceOverTime(12, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return tvl, err
		}
		return model.TvlOverTime{daily, monthly}, nil
	}
	volumeOverTime, err := r.VolumeOverTime(ctx, obj)
	if err != nil {
		return
	}
	priceOverTime, err := r.PriceOverTime(ctx, obj)
	if err != nil {
		return
	}
	for i, v := range volumeOverTime.Daily {
		var (
			dailyTvl string
			price    = priceOverTime.Daily[i]
		)
		dailyTvl, err = v.Token1.UsdValue(price, r.C.FusdcAddr)
		if err != nil {
			return
		}
		tvl.Daily = append(tvl.Daily, dailyTvl)
	}
	for i, v := range volumeOverTime.Monthly {
		var (
			monthlyTvl string
			price      = priceOverTime.Monthly[i]
		)
		monthlyTvl, err = v.Token1.UsdValue(price, r.C.FusdcAddr)
		if err != nil {
			return
		}
		tvl.Monthly = append(tvl.Monthly, monthlyTvl)
	}
	return tvl, nil
}

// YieldOverTime is the resolver for the yieldOverTime field.
func (r *seawaterPoolResolver) YieldOverTime(ctx context.Context, obj *seawater.Pool) (yield model.YieldOverTime, err error) {
	if obj == nil {
		return yield, fmt.Errorf("pool empty")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		daily, _, _, err := MockVolumeOverTime(31, r.C.FusdcAddr, obj.Token)
		if err != nil {
			return yield, err
		}
		monthly, _, _, err := MockVolumeOverTime(12, r.C.FusdcAddr, obj.Token)
		return model.YieldOverTime{daily, monthly}, nil
	}
	return yield, nil // TODO
}

// EarnedFeesAprfusdc is the resolver for the earnedFeesAPRFUSDC field.
func (r *seawaterPoolResolver) EarnedFeesAprfusdc(ctx context.Context, obj *seawater.Pool) ([]string, error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		return []string{"0", "0.15"}, nil
	}
	return nil, nil // TODO
}

// EarnedFeesAPRToken1 is the resolver for the earnedFeesAPRToken1 field.
func (r *seawaterPoolResolver) EarnedFeesAPRToken1(ctx context.Context, obj *seawater.Pool) ([]string, error) {
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		return []string{"0", "0.15"}, nil
	}
	return nil, nil // TODO
}

// LiquidityIncentives is the resolver for the liquidityIncentives field.
func (r *seawaterPoolResolver) LiquidityIncentives(ctx context.Context, obj *seawater.Pool) (amount model.Amount, err error) {
	if obj == nil {
		return amount, fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		return MockAmount(), nil
	}
	amount = model.Amount{
		Token:         obj.Token,
		Decimals:      int(obj.Decimals),
		Timestamp:     int(time.Now().Unix()),
		ValueUnscaled: types.EmptyUnscaledNumber(),
	}
	return amount, nil // TODO
}

// SuperIncentives is the resolver for the superIncentives field.
func (r *seawaterPoolResolver) SuperIncentives(ctx context.Context, obj *seawater.Pool) (amount model.Amount, err error) {
	if obj == nil {
		return amount, fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		return MockAmount(), nil
	}
	amount = model.Amount{
		Token:         obj.Token,
		Decimals:      int(obj.Decimals),
		Timestamp:     int(time.Now().Unix()),
		ValueUnscaled: types.EmptyUnscaledNumber(),
	}
	return amount, nil // TODO
}

// UtilityIncentives is the resolver for the utilityIncentives field.
func (r *seawaterPoolResolver) UtilityIncentives(ctx context.Context, obj *seawater.Pool) ([]model.UtilityIncentive, error) {
	return nil, nil // TODO
}

// Positions is the resolver for the positions field.
func (r *seawaterPoolResolver) Positions(ctx context.Context, obj *seawater.Pool, first *int, after *int) (positions model.SeawaterPositions, err error) {
	// If the user requested too large a limit, or they didn't supply a page size.
	if first == nil || *first > PoolPositionsPageSize {
		fst := PoolPositionsPageSize
		first = &fst
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = MockGetPoolPositions(obj.Token)
		return
	}
	stmt := r.DB.Table("seawater_active_positions_1").
		Where("pool = ?", obj.Token).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("pos_id < ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	p := obj.Token
	positions = model.SeawaterPositions{
		From:      pos[0].Id,
		To:        pos[len(pos)-1].Id,
		Pool:      &p,
		Positions: pos,
	}
	return
}

// PositionsForUser is the resolver for the positionsForUser field.
func (r *seawaterPoolResolver) PositionsForUser(ctx context.Context, obj *seawater.Pool, wallet string, first *int, after *int) (positions model.SeawaterPositions, err error) {
	w := types.AddressFromString(wallet)
	if obj == nil {
		return positions, fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		positions = MockGetPoolPositions(w)
		return
	}
	err = r.DB.Table("seawater_active_positions_1").
		Where("pool = ? and owner = ?", obj.Token, wallet).
		Scan(&positions).
		Error
	return
}

// Liquidity is the resolver for the liquidity field.
func (r *seawaterPoolResolver) Liquidity(ctx context.Context, obj *seawater.Pool) (liquidity []model.SeawaterLiquidity, err error) {
	if obj == nil {
		return nil, fmt.Errorf("empty pool")
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		liquidity = MockLiquidity(r.C.FusdcAddr, obj.Token)
		return
	}
	var groups []seawater.LiquidityGroup
	err = r.DB.Table("seawater_liquidity_groups_1").
		Where("pool = ?", obj.Token).
		Scan(&groups).
		Error
	if err != nil {
		return nil, err
	}
	//10 ** decimals
	fusdcDecimals_ := new(big.Int).SetInt64(int64(r.C.FusdcDecimals))
	fusdcDecimals_.Exp(Ten, fusdcDecimals_, nil)
	fusdcDecimals := new(big.Rat).SetInt(fusdcDecimals_)
	liquidity = make([]model.SeawaterLiquidity, len(groups))
	for i, g := range groups {
		// Take the average of the two ticks. We can simply add
		// half the big tick (5000) to the lowest tick.
		tick := g.Tick.Big()
		tick.Add(tick, FiveThousand)
		ratio := math.GetSqrtRatioAtTick(tick)
		price := math.GetPriceAtSqrtRatio(ratio)
		// Use the price data to get the USD value of token1, and
		// add token0 to it, assuming it maintains peg. This is
		// the price of the asset.
		usdAmt1 := new(big.Rat).SetInt(g.CumulativeAmount1.Big())
		usdAmt1.Quo(usdAmt1, fusdcDecimals)
		usdAmt0 := new(big.Rat).SetInt(g.CumulativeAmount0.Big())
		d := new(big.Int).SetInt64(int64(g.Decimals))
		d.Exp(Ten, d, nil)
		usdAmt0.Quo(usdAmt0, new(big.Rat).SetInt(d))
		usdAmt0.Mul(usdAmt0, price)
		usdAmt0.Add(usdAmt0, usdAmt1)
		liquidity[i] = model.SeawaterLiquidity{
			ID:        "", // TODO
			TickLower: g.Tick.String(),
			TickUpper: g.NextTick.String(),
			Price:     price.FloatString(5),
			Liquidity: usdAmt0.FloatString(5),
		}
	}
	// Group all the positions data from the most recent snapshot,
	// and make sure it's sorted. Then send that to the UI.
	return
}

// Swaps is the resolver for the swaps field.
func (r *seawaterPoolResolver) Swaps(ctx context.Context, obj *seawater.Pool, first *int, after *int) (swaps model.SeawaterSwaps, err error) {
	if obj == nil {
		return swaps, fmt.Errorf("empty pool")
	}
	// If the user requested a nil limit, or they're too big.
	if first == nil || *first > SwapPositionsPageSize {
		fst := SwapPositionsPageSize
		first = &fst
	}
	if after == nil {
		aft := 0
		after = &aft
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		MockDelay(r.F)
		swaps = MockSwaps(r.C.FusdcAddr, 150, obj.Token)
		return
	}
	// DB.RAW doesn't support chaining
	err = r.DB.Raw(
		"SELECT * FROM seawater_swaps_1(?, ?) WHERE (token_in = ? OR token_out = ?) AND timestamp > ? ORDER BY timestamp DESC LIMIT ?",
		r.C.FusdcAddr,
		r.C.FusdcDecimals,
		obj.Token,
		obj.Token,
		*after,
		*first,
	).
		Scan(&swaps.Swaps).
		Error
	swaps.Pool = &obj.Token
	return
}

// ID is the resolver for the id field.
func (r *seawaterPositionResolver) ID(ctx context.Context, obj *seawater.Position) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("empty position")
	}
	return fmt.Sprintf("pos:%v:%v", obj.Pool, obj.Id), nil
}

// Created is the resolver for the created field.
func (r *seawaterPositionResolver) Created(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	var pos seawater.Position
	err := r.DB.
		Table("events_seawater_mintposition").
		Select("created_by desc").
		Scan(&pos).
		Error
	if err != nil {
		return 0, nil
	}
	ts := pos.CreatedBy.Unix()
	return int(ts), nil
}

// PositionID is the resolver for the positionId field.
func (r *seawaterPositionResolver) PositionID(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	return obj.Id, nil
}

// Owner is the resolver for the owner field.
func (r *seawaterPositionResolver) Owner(ctx context.Context, obj *seawater.Position) (model.Wallet, error) {
	if obj == nil {
		return model.Wallet{}, fmt.Errorf("no position obj")
	}
	wallet, err := r.Query().GetWallet(ctx, obj.Owner.String())
	if err != nil {
		return model.Wallet{}, err
	}
	return *wallet, nil
}

// Pool is the resolver for the pool field.
func (r *seawaterPositionResolver) Pool(ctx context.Context, obj *seawater.Position) (pool seawater.Pool, err error) {
	if obj == nil {
		return seawater.Pool{}, fmt.Errorf("no position obj")
	}
	err = r.DB.Table("events_seawater_newpool").Where("token = ?", obj.Pool).Scan(&pool).Error
	return
}

// Lower is the resolver for the lower field.
func (r *seawaterPositionResolver) Lower(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	return int(obj.Lower.Int64()), nil
}

// Upper is the resolver for the upper field.
func (r *seawaterPositionResolver) Upper(ctx context.Context, obj *seawater.Position) (int, error) {
	if obj == nil {
		return 0, fmt.Errorf("no position obj")
	}
	return int(obj.Upper.Int64()), nil
}

// Liquidity is the resolver for the liquidity field.
func (r *seawaterPositionResolver) Liquidity(ctx context.Context, obj *seawater.Position) (model.PairAmount, error) {
	if obj == nil {
		return model.PairAmount{}, fmt.Errorf("no position obj")
	}
	var pool seawater.Pool
	err := r.DB.Table("events_seawater_newpool").
		Select("decimals").
		Where("token = ?", obj.Pool).
		First(&pool).
		Error
	if err != nil {
		return model.PairAmount{}, fmt.Errorf("finding new pool: %v", err)
	}
	var res seawater.PositionSnapshot
	err = r.DB.Table("snapshot_positions_latest_1").
		Where("pos_id = ?", obj.Id).
		First(&res).
		Error
	ts := int(res.UpdatedBy.Unix())
	switch {
	case errors.Is(err, gorm.ErrRecordNotFound):
		// We didn't find a pair amount! Return nothing.
		return model.PairAmount{
			Timestamp: ts,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     ts,
				ValueUnscaled: types.EmptyUnscaledNumber(),
			},
			Token1: model.Amount{
				Token:         obj.Pool,
				Decimals:      int(pool.Decimals),
				Timestamp:     ts,
				ValueUnscaled: types.EmptyUnscaledNumber(),
			},
		}, nil
	case err == nil:
		// Do nothing. The good path!
	default:
		return model.PairAmount{}, fmt.Errorf("position id: %#v: %v", obj.Id, err)
	}
	return model.PairAmount{
		Timestamp: ts,
		Fusdc: model.Amount{
			Token:         r.C.FusdcAddr,
			Decimals:      r.C.FusdcDecimals,
			Timestamp:     ts,
			ValueUnscaled: res.Amount1,
		},
		Token1: model.Amount{
			Token:         obj.Pool,
			Decimals:      int(pool.Decimals),
			Timestamp:     ts,
			ValueUnscaled: res.Amount0,
		},
	}, nil
}

// Sum is the resolver for the sum field.
func (r *seawaterPositionsResolver) Sum(ctx context.Context, obj *model.SeawaterPositions) (amounts []model.PairAmount, err error) {
	if obj == nil {
		return nil, fmt.Errorf("empty positions")
	}
	// Try to figure out whether we're servicing a per-wallet request, or a per-pool request.
	var results []seawater.SnapshotPositionsLatestDecimalsGroup
	stmt := r.DB
	switch {
	case obj.Pool != nil:
		stmt = stmt.
			Table("snapshot_positions_latest_decimals_grouped_1").
			Where("pool = ?", obj.Pool)
	case obj.Wallet != nil:
		stmt = stmt.
			Raw(
				"SELECT * FROM snapshot_positions_latest_decimals_grouped_user_1(?)",
				obj.Wallet,
			)
	default:
		return nil, nil // Assume the query above didn't find any responses.
	}
	if err := stmt.Scan(&results).Error; err != nil {
		return nil, err
	}
	amounts = make([]model.PairAmount, len(results))
	now := int(time.Now().Unix())
	for i, res := range results {
		amounts[i] = model.PairAmount{
			Timestamp: now,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount0,
			},
			Token1: model.Amount{
				Token:         res.Pool,
				Decimals:      int(res.Decimals),
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount1,
			},
		}
	}
	return
}

// Next is the resolver for the next field.
func (r *seawaterPositionsResolver) Next(ctx context.Context, obj *model.SeawaterPositions, first *int) (model.SeawaterPositions, error) {
	panic(fmt.Errorf("not implemented: Next - next"))
}

// Pool is the resolver for the pool field.
func (r *seawaterSwapResolver) Pool(ctx context.Context, obj *model.SeawaterSwap) (seawater.Pool, error) {
	var token string
	if obj.TokenIn == r.C.FusdcAddr {
		token = obj.TokenOut.String()
	} else {
		token = obj.TokenIn.String()
	}
	pool, err := r.Query().GetPool(ctx, token)
	if err != nil {
		return seawater.Pool{}, err
	}
	return *pool, nil
}

// Sender is the resolver for the sender field.
func (r *seawaterSwapResolver) Sender(ctx context.Context, obj *model.SeawaterSwap) (model.Wallet, error) {
	if obj == nil {
		return model.Wallet{}, fmt.Errorf("empty swap")
	}
	wallet, err := r.Query().GetWallet(ctx, obj.Sender.String())
	if err != nil {
		return model.Wallet{}, err
	}
	return *wallet, nil
}

// AmountIn is the resolver for the amountIn field.
func (r *seawaterSwapResolver) AmountIn(ctx context.Context, obj *model.SeawaterSwap) (model.Amount, error) {
	if obj == nil {
		return model.Amount{}, fmt.Errorf("empty swap")
	}
	return model.Amount{
		Token:         obj.TokenIn,
		Decimals:      obj.TokenInDecimals,
		Timestamp:     obj.Timestamp,
		ValueUnscaled: obj.AmountIn,
	}, nil
}

// AmountOut is the resolver for the amountOut field.
func (r *seawaterSwapResolver) AmountOut(ctx context.Context, obj *model.SeawaterSwap) (model.Amount, error) {
	if obj == nil {
		return model.Amount{}, fmt.Errorf("empty swap")
	}
	return model.Amount{
		Token:         obj.TokenOut,
		Decimals:      obj.TokenOutDecimals,
		Timestamp:     obj.Timestamp,
		ValueUnscaled: obj.AmountOut,
	}, nil
}

// Sum is the resolver for the sum field.
func (r *seawaterSwapsResolver) Sum(ctx context.Context, obj *model.SeawaterSwaps) (amounts []model.PairAmount, err error) {
	if obj == nil {
		return nil, fmt.Errorf("empty swaps")
	}
	// Try to figure out whether we're servicing a per-wallet request, or a per-pool request.
	var results []seawater.SwapsDecimalsGroup
	stmt := r.DB
	switch {
	case obj.Pool != nil:
		stmt = stmt.
			Raw(
				"SELECT * FROM swaps_decimals_pool_group_1(?,?,?)",
				r.C.FusdcAddr,
				r.C.FusdcDecimals,
				*obj.Pool,
			)
	case obj.Wallet != nil:
		stmt = stmt.
			Raw(
				"SELECT * FROM swaps_decimals_user_group_1(?,?,?)",
				r.C.FusdcAddr,
				r.C.FusdcDecimals,
				*obj.Wallet,
			)
	default:
		return nil, nil // Assume the query above didn't find any responses.
	}
	if err := stmt.Scan(&results).Error; err != nil {
		return nil, err
	}
	amounts = make([]model.PairAmount, len(results))
	now := int(time.Now().Unix())
	for i, res := range results {
		amounts[i] = model.PairAmount{
			Timestamp: now,
			Fusdc: model.Amount{
				Token:         r.C.FusdcAddr,
				Decimals:      r.C.FusdcDecimals,
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount0,
			},
			Token1: model.Amount{
				Token:         res.Pool,
				Decimals:      int(res.Decimals),
				Timestamp:     now,
				ValueUnscaled: res.CumulativeAmount1,
			},
		}
	}
	return
}

// Next is the resolver for the next field.
func (r *seawaterSwapsResolver) Next(ctx context.Context, obj *model.SeawaterSwaps, first *int) (model.SeawaterSwaps, error) {
	panic(fmt.Errorf("not implemented: Next - next"))
}

// ID is the resolver for the id field.
func (r *walletResolver) ID(ctx context.Context, obj *model.Wallet) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("no wallet obj")
	}
	return "wallet:" + obj.Address.String(), nil
}

// Address is the resolver for the address field.
func (r *walletResolver) Address(ctx context.Context, obj *model.Wallet) (string, error) {
	if obj == nil {
		return "", fmt.Errorf("no token")
	}
	return obj.Address.String(), nil
}

// Balances is the resolver for the balances field.
func (r *walletResolver) Balances(ctx context.Context, obj *model.Wallet) ([]model.Amount, error) {
	panic(fmt.Errorf("not implemented: Balances - balances"))
}

// Positions is the resolver for the positions field.
func (r *walletResolver) Positions(ctx context.Context, obj *model.Wallet, first *int, after *int) (positions model.SeawaterPositions, err error) {
	if obj == nil {
		return positions, fmt.Errorf("empty wallet")
	}
	// Prevent nil firsts, or past the limit.
	if first == nil || *first > PoolPositionsPageSize {
		fst := PoolPositionsPageSize
		first = &fst
	}
	if r.F.Is(features.FeatureGraphqlMockGraph) {
		r.F.On(features.FeatureGraphqlMockGraphDataDelay, func() error {
			MockDelay(r.F)
			return nil
		})
		positions = MockGetPoolPositions("0x65dfe41220c438bf069bbce9eb66b087fe65db36")
		return
	}
	stmt := r.DB.Table("seawater_active_positions_1").
		Where("owner = ?", obj.Address).
		Limit(*first).
		Order("created_by desc")
	if after != nil {
		stmt = stmt.Where("pos_id > ?", *after)
	}
	var pos []seawater.Position
	if err := stmt.Scan(&pos).Error; err != nil || pos == nil {
		return positions, err
	}
	w := obj.Address
	var to int
	if l := len(pos); l > 0 {
		to = int(pos[l-1].CreatedBy.Unix())
	}
	positions = model.SeawaterPositions{
		From:      *first,
		To:        to,
		Wallet:    &w,
		Positions: pos,
	}
	return
}

// Amount returns AmountResolver implementation.
func (r *Resolver) Amount() AmountResolver { return &amountResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// SeawaterLiquidity returns SeawaterLiquidityResolver implementation.
func (r *Resolver) SeawaterLiquidity() SeawaterLiquidityResolver {
	return &seawaterLiquidityResolver{r}
}

// SeawaterPool returns SeawaterPoolResolver implementation.
func (r *Resolver) SeawaterPool() SeawaterPoolResolver { return &seawaterPoolResolver{r} }

// SeawaterPosition returns SeawaterPositionResolver implementation.
func (r *Resolver) SeawaterPosition() SeawaterPositionResolver { return &seawaterPositionResolver{r} }

// SeawaterPositions returns SeawaterPositionsResolver implementation.
func (r *Resolver) SeawaterPositions() SeawaterPositionsResolver {
	return &seawaterPositionsResolver{r}
}

// SeawaterSwap returns SeawaterSwapResolver implementation.
func (r *Resolver) SeawaterSwap() SeawaterSwapResolver { return &seawaterSwapResolver{r} }

// SeawaterSwaps returns SeawaterSwapsResolver implementation.
func (r *Resolver) SeawaterSwaps() SeawaterSwapsResolver { return &seawaterSwapsResolver{r} }

// Wallet returns WalletResolver implementation.
func (r *Resolver) Wallet() WalletResolver { return &walletResolver{r} }

type amountResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type seawaterLiquidityResolver struct{ *Resolver }
type seawaterPoolResolver struct{ *Resolver }
type seawaterPositionResolver struct{ *Resolver }
type seawaterPositionsResolver struct{ *Resolver }
type seawaterSwapResolver struct{ *Resolver }
type seawaterSwapsResolver struct{ *Resolver }
type walletResolver struct{ *Resolver }
