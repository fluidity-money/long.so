
type Query {
  pools: [SeawaterPool!]!

  """
  getPool using the address of the token that's involved.

  Follows the same caching behaviour as the pools endpoint.
  """
  getPool(address: String!): SeawaterPool

  """
  getPoolPositions using the address of the pool involved.

  Very cached. Should not be used. The getPoolPositionsForOwner is better.
  """
  getPoolPositions(address: String!): [SeawaterPosition!]

  """
  getPosition that's owned by any pool using it's ID, based on what's known to the database.

  Skips the cache for the most part.
  """
  getPosition(id: String!): SeawaterPosition

  """
  getPositions that're owned by a specific wallet.

  Uses the cache with a 10-20 second window.
  """
  getPositions(wallet: String!): [SeawaterPosition!]!

  """
  getWallet based on information including balances. SHOULD NOT be used to get
  information that's needed consistently. Use the frontend instead after getting addresess
  elsewhere.
  """
  getWallet(address: String!): Wallet

  """
  getSwaps made using a pool. Safe to use to get up to date information on swaps going
  through the UI.
  """
  getSwaps(pool: String!): [SeawaterSwap!]
}

type Mutation {
  setVolumeYieldPriceAndTVLForLastHour: ID
}

type SeawaterPool {
  id: ID! # address

  """
  Address of the pool, and of the token that's traded.
  """
  address: String!

  """
  Tick spacing of the current pool, useful for graph rendering.
  """
  tickSpacing: String!

  """
  More token information about the counter asset that's available.
  """
  token: Token!

  """
  Information on the current price, last cached. Determined by the last tick of a trade
  that was made.
  """
  price: String!

  """
  Historical price over time data that's available.
  """
  priceOverTime: PriceOverTime!

  volumeOverTime: VolumeOverTime!
  liquidityOverTime: LiquidityOverTime!
  tvlOverTime: TvlOverTime!
  yieldOverTime: YieldOverTime!

  earnedFeesAPRFUSDC: [String!]!
  earnedFeesAPRToken1: [String!]!

  liquidityIncentives: Amount!
  superIncentives: Amount!
  utilityIncentives: [UtilityIncentive!]!

  positions: [SeawaterPosition!]!
  positionsForUser(address: String!): [SeawaterPosition!]!

  """
  Liquidity available in a pool. It's best to avoid questioning the return data too much
  on this, and sticking to unscaled values. This returns a lot of data.
  """
  liquidity: [SeawaterLiquidity!]!

  swaps: [SeawaterSwap!]!
  swapsForUser(address: String!): [SeawaterSwap!]!
}

type VolumeOverTime {
  daily: [PairAmount!]! # loads a month worth of daily data
  monthly: [PairAmount!]! # loads 12 months of data
}

type LiquidityOverTime {
  daily: [PairAmount!]! # loads a month worth of daily data (31 items)
  monthly: [PairAmount!]! # loads 12 months of data
}

type YieldOverTime {
  daily: [PairAmount!]! # loads a month worth of daily data (31 items)
  monthly: [PairAmount!]! # loads 12 months of data
}

type PriceOverTime {
  daily: [String!]! # loads a month worth of daily data (31 items)
  monthly: [String!]! # loads 12 months of data
}

type TvlOverTime {
  daily: [String!]! # loads a month worth of daily data (31 items)
  monthly: [String!]! # loads 12 months of data
}

"""
SeawaterLiquidity available in a pool summed and grouped by ticks.
"""
type SeawaterLiquidity {
  id: ID! # tick number (liq:tick number)
  tick: String!
  positions: [SeawaterPosition!]!
  amount: PairAmount!
}

"""
SeawaterPosition owned by a user.
"""
type SeawaterPosition {
  id: ID! # positionId (pos:positionId)

  positionId: String!
  owner: Wallet!
  pool: SeawaterPool!
  lower: String!
  upper: String!
  liquidity: PairAmount!
}

type SeawaterSwap {
  # no caching takes place with this.
  timestamp: Int!
  sender: Wallet!
  amountIn: Amount!
  amountOut: Amount!
}

type PairAmount {
  timestamp: Int!
  fusdc: Amount!
  token1: Amount!
}

type Amount {
  token: Token!
  decimals: Int!
  timestamp: Int!

  valueUnscaled: String!
  valueScaled: String!
  valueUsd: String!
}

type Wallet {
  id: ID! # address

  address: String!
  balances: [TokenBalance!]!
  positions: [SeawaterPosition!]
}

type TokenBalance {
  token: Token!
  balance: Amount!
}

type Token {
  address: String!
  name: String!
  totalSupply: String!
  decimals: Int!
  symbol: String!
}

type UtilityIncentive {
  amountGivenOut: String!
  maximumAmount: String!
}
