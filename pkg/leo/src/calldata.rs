use stylus_sdk::alloy_primitives::{Address, U256};

use crate::error::Error;

//transferFrom(address,address,uint256)
const TRANSFER_FROM_SELECTOR: [u8; 4] = [0x23, 0xb8, 0x72, 0xdd];

pub fn write_selector(bytes: &mut [u8], selector: &[u8; 4]) {
    bytes[0..4].copy_from_slice(&selector[..])
}
pub fn write_address(bytes: &mut [u8], slot: usize, address: Address) {
    bytes[4 + 32 * slot + 12..4 + 32 * slot + 32].copy_from_slice(&address.0 .0)
}
pub fn write_u256(bytes: &mut [u8], slot: usize, uint: U256) {
    bytes[4 + 32 * slot..4 + 32 * slot + 32].copy_from_slice(&uint.to_be_bytes::<32>())
}

pub fn unpack_i32(data: &[u8]) -> Option<i32> {
    data[28..].try_into().ok().map(i32::from_be_bytes)
}

pub fn unpack_u128(data: &[u8]) -> Option<u128> {
    data[16..].try_into().ok().map(u128::from_be_bytes)
}

pub fn unpack_u128_double(data: &[u8]) -> Option<(u128, u128)> {
    let first = u128::from_be_bytes(data[16..32].try_into().ok()?);
    let end = u128::from_be_bytes(data[32 + 16..].try_into().ok()?);
    Some((first, end))
}

pub fn pack_transfer_from(sender: Address, recipient: Address, amount: U256) -> [u8; 4 + 32 * 3] {
    let mut cd = [0_u8; 4 + 32 * 3];
    write_selector(&mut cd, &TRANSFER_FROM_SELECTOR);
    write_address(&mut cd, 0, sender);
    write_address(&mut cd, 1, recipient);
    write_u256(&mut cd, 2, amount);
    cd
}

pub fn unpack_bool_safe(data: &[u8]) -> Result<(), Vec<u8>> {
    match data.get(31) {
        None | Some(1) => Ok(()),
        _ => Err(Error::ReturnedFalse.into()),
    }
}

#[test]
fn test_unpack_u128_double() {
    assert_eq!(
        unpack_u128_double(&[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7a,
        ]),
        Some((u128::MAX, 122))
    )
}

#[test]
fn test_unpack_i32() {
    assert_eq!(
        unpack_i32(&[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x7b,
        ]),
        Some(123)
    );
    assert_eq!(
        unpack_i32(&[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x7f, 0xff, 0xff, 0xff,
        ]),
        Some(i32::MAX)
    );
    assert_eq!(
        unpack_i32(&[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x7f, 0xff, 0xff, 0xff,
        ]),
        Some(i32::MAX)
    );
}

#[test]
fn test_unpack_u128() {
    assert_eq!(
        unpack_u128(&[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x7b
        ]),
        Some(123)
    );
    assert_eq!(
        unpack_u128(&[
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff,
        ]),
        Some(u128::MAX)
    );
}

#[test]
fn test_pack_transfer_from() {
    use stylus_sdk::alloy_primitives::address;

    assert_eq!(
        &pack_transfer_from(
            address!("6221a9c005f6e47eb398fd867784cacfdcfff4e7"),
            address!("feb6034fc7df27df18a3a6bad5fb94c0d3dcb6d5"),
            U256::from(100)
        ),
        &[
            //cast calldata 'transferFrom(address,address,uint256)' 0x6221a9c005f6e47eb398fd867784cacfdcfff4e7 0xfeb6034fc7df27df18a3a6bad5fb94c0d3dcb6d5 100
            0x23, 0xb8, 0x72, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x62, 0x21, 0xa9, 0xc0, 0x05, 0xf6, 0xe4, 0x7e, 0xb3, 0x98, 0xfd, 0x86,
            0x77, 0x84, 0xca, 0xcf, 0xdc, 0xff, 0xf4, 0xe7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xb6, 0x03, 0x4f, 0xc7, 0xdf, 0x27, 0xdf,
            0x18, 0xa3, 0xa6, 0xba, 0xd5, 0xfb, 0x94, 0xc0, 0xd3, 0xdc, 0xb6, 0xd5, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x64,
        ]
    );
}
